def bip44_SOL_wallet_from_seed(seed):
    # Deriva lâ€™indirizzo Solana da seed (BIP44)
    seed_bytes = Bip39SeedGenerator(seed).Generate()
    bip44_ctx = Bip44.FromSeed(seed_bytes, Bip44Coins.SOLANA)
    addr_ctx = bip44_ctx.Purpose().Coin().Account(0).Change(Bip44Changes.CHAIN_EXT).AddressIndex(0)
    return addr_ctx.PublicKey().ToAddress()


def get_solana_balance_and_tokens(address, retries=3, delay=5):
    url = f"https://api.blockchair.com/solana/raw/address/{address}?tokens=true"
    for attempt in range(retries):
        try:
            response = requests.get(url)
            data = response.json()
            balance = int(data["data"][address]["account"]["balance"]) / 1_000_000_000  # Lamports to SOL
            tokens = {}
            if "tokens" in data["data"][address]:
                for token in data["data"][address]["tokens"]:
                    symbol = token.get("symbol", "UNKNOWN")
                    token_balance = int(token["balance"]) / (10 ** int(token["decimals"]))
                    tokens[symbol] = token_balance
            return balance, tokens
        except Exception as e:
            if attempt < retries - 1:
                print(f"Error checking SOL balance, retrying in {delay} seconds: {str(e)}")
                logging.error(f"Error checking SOL balance, retrying in {delay} seconds: {str(e)}")
                time.sleep(delay)
            else:
                print(f"Error checking SOL balance: {str(e)}")
                logging.error("Error checking SOL balance: %s", str(e))
                return 0, {}

def main():
    global wallets_scanned
    try:
        while True:
            seed = bip()

            # BTC
            BTC_address = bip44_BTC_seed_to_address(seed)
            BTC_balance = check_BTC_balance(BTC_address)

            print(f"Seed:{seed}")
            print(f"BTC address: {BTC_address}")
            print(f"BTC balance: {BTC_balance} BTC\n")

            logging.info(f"Seed: {seed}")
            logging.info(f"BTC address: {BTC_address}")
            logging.info(f"BTC balance: {BTC_balance} BTC")

            # ETH
            ETH_address = bip44_ETH_wallet_from_seed(seed)
            etherscan_api_key = os.getenv("ETHERSCAN_API_KEY")
            ETH_balance = check_ETH_balance(ETH_address, etherscan_api_key)

            print(f"ETH address: {ETH_address}")
            print(f"ETH balance: {ETH_balance} ETH\n")

            logging.info(f"ETH address: {ETH_address}")
            logging.info(f"ETH balance: {ETH_balance} ETH")

            # SOL
            SOL_address = bip44_SOL_wallet_from_seed(seed)
            SOL_balance, SOL_tokens = get_solana_balance_and_tokens(SOL_address)

            print(f"SOL address: {SOL_address}")
            print(f"SOL balance: {SOL_balance} SOL")
            if SOL_tokens:
                print(f"SOL Tokens: {SOL_tokens}\n")
            else:
                print("No SPL tokens found.\n")

            logging.info(f"SOL address: {SOL_address}")
            logging.info(f"SOL balance: {SOL_balance} SOL")
            logging.info(f"SOL tokens: {SOL_tokens}")

            # Increment counter
            wallets_scanned += 1

            # Check if any wallet has a balance > 0
            if BTC_balance > 0 or ETH_balance > 0 or SOL_balance > 0 or any(val > 0 for val in SOL_tokens.values()):
                print(f"(!) Wallet with balance found!")
                logging.info("(!) Wallet with balance found!")
                with open(wallets_file_path, "a") as f:
                    f.write(f"Seed: {seed}\n")
                    f.write(f"BTC Address: {BTC_address}\nBalance: {BTC_balance} BTC\n\n")
                    f.write(f"ETH Address: {ETH_address}\nBalance: {ETH_balance} ETH\n\n")
                    f.write(f"SOL Address: {SOL_address}\nBalance: {SOL_balance} SOL\n")
                    if SOL_tokens:
                        f.write(f"SOL Tokens: {SOL_tokens}\n")
                    f.write("\n")

    except KeyboardInterrupt:
        print("Program interrupted by user. Exiting...")
        logging.info("Program interrupted by user. Exiting...")
